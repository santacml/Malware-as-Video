#!/usr/bin python3
from assemblyScanner import Scanner
import pickle
import random
import numpy
import time


class Vectorizor(object):
    def __init__(self, maxVal=1, maxLineLen=10):
        # works through multiple vectorizings -> multiple pgms 
        # self.values = {}
        # self.takenVals = []
        # self.maxVal=maxVal
        # self.maxLineLen = maxLineLen
        
        # self.vars = []     # don't need this anymore?
        self.bannedVars = []
        
        
        self.files = []
        self.maxFileLen = 0
        self.maxLineLen = 0
        # self.absoluteMaxFileLen = 50000
        
        # self.vocabSize = 5000  #idk, this will be an issue
        # self.takenNums = []
        
        self.currTokNum = 0
        self.tokToNum = {}
        # self.currTokNum, self.tokToNum = pickle.load(open("tokToNum.pkl", "rb"))
        self.currTokNum =  self.currTokNum + 1
        # print("loaded tokToNum")
        # print(self.currTokNum)
        
        # pruning less frequency reduces extraneous prunes
        # but it also takes waaaaaaay longer to do all the math
        self.pruneFrequency = 5
        self.numFilesScanned = 0
        
        self.answers = []
        
        # self.tokFreqs = [0,0]  # list of frequencies -> index is frequency!
        
        self.accumFreqs = numpy.asarray([0])
        self.availableNums = []
        
        
    def dumpVocab(self):
        pickle.dump([self.currTokNum, self.tokToNum], open("tokToNum.pkl", "wb"))
        
    def itemReplacer(self, testItem):
        item = testItem
        
        if len(testItem) > 1 :
            if testItem[-1] == "h":
                testItem = testItem[:-1]
            try:
                int(testItem, 16)
                # if we can convert it from hex, then say item is a hex num
                item = "hexnum"
            except ValueError:
                pass
        if item.startswith("sub_"):
            item = "sub"
        elif item.startswith("off_"):
            item = "off"
        elif item.startswith("unk_"):
            item = "unk"
        elif item.startswith("loc_"):
            item = "loc"
        elif item.startswith("dword_"):
            item = "dword"
        elif item.startswith("word_"):
            item = "word"
        elif item.startswith("locret_"):
            item = "locret"
        elif item.startswith("var_"):
            item = "var"
        elif item.startswith("byte_"):
            item = "byte"
        elif item.startswith("arg_"):
            item = "arg"
        elif item.startswith("nullsub_"):
            item = "nullsub"
        elif item.startswith("?"):
            item = "?thing"
        elif item.startswith("__"):
            item = "__thing"
        return item
        
    def findItem(self, item):
        result = self.tokToNum.get(item, 0)
        if not result:
            # print(item)
            if len(self.availableNums) > 0:
                result = self.availableNums.pop(0)
                
                self.tokToNum[item] = result
                
            else:
                self.currTokNum = self.currTokNum + 1
                self.tokToNum[item] = self.currTokNum
                
                # self.vars.append(item) # just for padding, idk
                
                result = self.currTokNum
            
            # self.tokFreqs.append(0)
        
        # self.tokFreqs[result] = self.tokFreqs[result] + 1
        return result
        
    def testHex(self, testItem):
        try:
            if len(testItem) != 2: return None
            return int(testItem, 16)
        except ValueError:
            return None
        
    def vectorize(self, fileName, answer, watchOutForDB=False):
        newLines = []
        with open(fileName, 'rb') as f:
            for line in f:
                line = line.lower()
                if line[0:6] != b".text:" and line[0:5] != b"code:" and line[0:4] != b"UPX1": # filter off only text
                    continue
                else:
                    # line = line[6:] # get rid of ".text"
                    line = line[14:] # get rid of ".text" and hex location
                
                try:
                    line = line.decode('ascii')
                except UnicodeDecodeError:
                    continue
                # print(line.split())
                line = line.split()
                
                linecopy = [item for item in line]
                
                newLine = []
                if len(line) == 0: continue
                # print(line)
                convert = self.testHex(line.pop(0))
                while len(line) > 0 and not convert == None: 
                    newLine.append(convert)
                    convert = self.testHex(line.pop(0))
                # print(newLine, line)
                if len(newLine) == 0: continue
                
                
                
                if watchOutForDB and newLine[-1] == 219:
                    # print(newLine, linecopy)
                    itemAfterDB = linecopy[linecopy.index("db") + 1]
                    if itemAfterDB[-1] == "h":
                        result = self.testHex(itemAfterDB[:-1])
                        if result != None:
                            newLine.pop(-1)
                        else:
                            # for cases like push!
                            pass
                            print(newLine, linecopy)
                            time.sleep(1)
                            
                    elif len(linecopy) == 3:
                            newLine.pop(-1)
                    
                
                newLines.append(newLine)
                if len(newLine) > self.maxLineLen: self.maxLineLen = len(newLine)
        
       
       
        if len(newLines) > self.maxFileLen: self.maxFileLen = len(newLines) 
        
        if len(newLines) == 0:
            print("DID NOT FIND ANY MACHINE CODE.")
            return
        self.files.append(newLines)
        self.answers.append(answer) # maintains order with files
        self.numFilesScanned += 1
        print("num files scanned:", self.numFilesScanned)
        print("file length", len(newLines))
        print("max file len", self.maxFileLen)
        print("max line len", self.maxLineLen)
        # print("num vars",self.currTokNum) # doesn't make sense as we are just keeping hex!
        return [newLines, answer]
        

            
            
            