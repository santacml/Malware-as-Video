from assemblyVectorizor import Vectorizor
from postVectorizeDataEditor import *
import csv
import random
import numpy as np
    
# helper functions
    
def runThroughGenerator(gen, steps):
    for x in range(0, int(steps)):
        train_x, train_y = next(gen)
        print("done gen", x)
        
        
def getOpcodes(fileLines):
    newFileLines = [[], fileLines[1]]
    # 0/0
    for row in fileLines[0]:
        if len(row) > 0:
            # print(row)
            newFileLines[0].append([row[0]])
            # print(newFileLines[0][-1])
            
    return newFileLines
    
def padEachLine(fileLines, maxLineLen):
    # maxLineLen = vectorizor.maxLineLen
    emptyLine = [0] * maxLineLen
    
    
    for line in fileLines[0]:
        for n in range(0,maxLineLen-len(line)): line.append(0)
        
    while len(fileLines[0]) % 2500 != 0:   # CHANGE ME interval len
        fileLines[0].append(emptyLine)
        
    # print(fileLines[0])
        
    return fileLines
    
def reformatLines(fileLines, rowSize):
    # reformat to no padding
    
    # rowSize = 10
    
    emptyLine = [0] * rowSize
    
    fileASM = [item for sublist in fileLines[0] for item in sublist]
    # print(fileASM)
    
    # this is super inefficient
    # print(fileLines)
    # pool 10 
    while len(fileASM) % (rowSize*rowSize) != 0:
        fileASM.append(0)
        
    fileASM = np.asarray(fileASM)
        
    # print(fileASM.reshape((-1, 25)))
    fileLines[0] = fileASM.reshape((-1, rowSize)).tolist()
    # print(len(fileLines[0]))
    
    while len(fileLines[0]) % (rowSize*rowSize*10) != 0:   # CHANGE ME interval len
        fileLines[0].append(emptyLine)
        
    # print(fileLines[0])
        
    # print(0/0)
    return fileLines
    
    
    
# raw vectorize functions take in .asm files and turn them into .pklz numpy files
    
def createRawVectorizedWindows(folderPrefix, vectorizedFolder, watchOutForDB=True):
    files = []
    import glob, os, gzip
    files.extend(glob.glob(folderPrefix + r"\*.lst"))

    # random.shuffle(files)
    # THIS IS EITHER M OR R!!!!!!!!!!!!!!!!

    #first, turn into tokens, then call vectorizor

    f = None
    vectorizor = Vectorizor()

        
    # vectorizor.maxLineLen = 18
    # vectorizor.maxFileLen = 2277766

    numScanned = 0
    for file in files:
            
        print(file)
        name = os.path.basename(file)[:-4] # get rid of .asm, better way, idc
        answer = [0]
        
        # watchOutForDB controls for the db error at end of lines
        toPickle = vectorizor.vectorize(file, answer, watchOutForDB=watchOutForDB) # WILL HAVE [NEWLINES, ANSWER]
        
        # every 100 files start a new thing. Results in 100 folders? I guess.
        if numScanned % 500 == 0:
            if f: f.close()
            f = gzip.open(vectorizedFolder + r"\tempAssemblyVectorized" + str(numScanned) + '.pklz', 'w+b')  # this should clear
        
        if vectorizor.files:
            # pickle.dump(padEachLine(toPickle, 10), f) # just dump the one file we've scanned
            pickle.dump(toPickle, f) # just dump the one file we've scanned
        else:
            print("ERROR file:", file) # this will happen if there are no files :) good job past me
        
        vectorizor.files = []  # idk, whatever. ducktaaaaaaaaaaaape
        
        numScanned += 1
        
    f.close()
        


    print("FINAL LENGTHS:")
    print("Num of files:", vectorizor.numFilesScanned)
    print("Num of lines per file:", vectorizor.maxFileLen)
    print("banned vars", len(vectorizor.bannedVars))
    
def createRawVectorizedKaggle(folderPrefix, vectorizedFolder):
    files = []
    import glob, os, gzip
    files.extend(glob.glob(folderPrefix + r"\*.asm"))


    f = None
    vectorizor = Vectorizor()


    # vectorizor.maxLineLen = 18
    # vectorizor.maxFileLen = 480941
    
    answers = {}
    with open("kaggleTrainLabels.csv", "r") as f:
        reader = csv.reader(f)
        for row in reader:
            name = row[0]
            answer = [int(row[1])]
            answers[name] = answer
        

    # '''
    # this section is for reading the raw, raw data and vectorizing
    # outputs the tempAssemblyVectorized.pklz files
    # record the maxLineLen and maxFileLen above to use for future
    # no real reason to ever do this again

    numScanned = 0
    for file in files:
        # if numScanned < 0: 
            # numScanned += 1
            # continue # us this to manual override to a count
            
        print(file)
        name = os.path.basename(file)[:-4] # get rid of .asm, better way, idc
        answer = answers[name]
        
        # lines = Scanner().scan(file)
        # vectorizor.vectorize(lines, answer)
        
        toPickle = vectorizor.vectorize(file, answer) # WILL HAVE [NEWLINES, ANSWER]
        # print(0/0)
        # print(vectorizor.files)
        
        # every 500 files start a new thing. 
        if numScanned % 500 == 0:
            if f: f.close()
            # f = open('tempAssemblyVectorized' + str(numScanned) + '.pklz', 'wb').truncate() # clear file
            f = gzip.open(vectorizedFolder + r"\tempAssemblyVectorized" + str(numScanned) + '.pklz', 'w+b')  # this should clear
            # f.truncate()  # not in gzip
            # vectorizor.dumpVocab()
        
        if vectorizor.files:
            # pickle.dump(vectorizor.files[0], f) # just dump the one file we've scanned
            pickle.dump(toPickle, f) # just dump the one file we've scanned
        else:
            print("ERROR file:", file) # this will happen if there are no files :) good job past me
        
        vectorizor.files = []  # idk, whatever. ducktaaaaaaaaaaaape
        
        numScanned += 1
        
    f.close()
    
    
    print("FINAL LENGTHS:")
    print("Num of files:", vectorizor.numFilesScanned)
    print("Num of lines per file:", vectorizor.maxFileLen)
    print("Vocab size", len(vectorizor.vars))
        
    # '''
    
    stats = {
        "numFiles": vectorizor.numFilesScanned,
        "maxFileLen": vectorizor.maxFileLen,
        "vocabSize": len(vectorizor.vars),
        "maxLineLen": vectorizor.maxLineLen
    }
    
    
    
    return stats

    
# final vectorize files turn raw vectorized into 
    
def createFinalVectorizedKaggleOnly(fullAssemblyFileName, validFileName, rawVectorizedPrefix, stats, numSamplesTrain, padLines=True, cutoff=None):
    if cutoff: print("Using cutoff", cutoff)
    if padLines: print("PADDING EACH LINE")
    # '''
    writeMe = gzip.open(fullAssemblyFileName, 'w+b')
    
    maxLineLen = stats["maxLineLen"]
    
    shortFilesCount = 0
    fileCount = 0
    classCounts = [0]*10
    for x in range(0,10500, 500):
        # I only want one copy of all these, keep it here
        zippedFile = rawVectorizedPrefix + str(x) + ".pklz"
        readMe = gzip.open(zippedFile, "r")
        while True:
            try:
                # grab 700 data samples, 200 validation
                if fileCount == numSamplesTrain:
                # if fileCount == 342:   #9*38=342
                    writeMe = gzip.open(validFileName, 'w+b')  # this should clear\
                
                fileLines = pickle.load(readMe)
                
                
                # OPTIONS
                while cutoff and len(fileLines[0]) > cutoff:
                    print("class", fileLines[1][0], "over cutoff, trying again")
                    fileLines = pickle.load(readMe)
                    # continue DOES NOT WORK biases dataset :(
                if padLines:
                    pickle.dump(padEachLine(fileLines, maxLineLen), writeMe)
                else:
                    pickle.dump(reformatLines(fileLines), writeMe)
                # pickle.dump(padEachLineKeep11(fileLines), writeMe)
                
                
                
                fileCount += 1
                classCounts[fileLines[1][0]] += 1
                print("file:", fileCount, "len", len(fileLines[0]), classCounts)
            except EOFError:
                print("starting next file", x)
                break
    
def createFinalVectorizedKaggleAndWindows(fullAssemblyFileName, validFileName, numSamplesTrain, totalSamples, malwareRawPrefix, winexeRawPrefix, windllRawPrefix,
                                          binaryAnswers=True, padLines=True, cutoff=None, zeroDayClass=None, zeroDayFileName=None, opcodesonly=False):
    print("creating final vectorized kaggle and windows")
    if cutoff: print("Using cutoff", cutoff)
    if padLines: print("padding each line")
    if zeroDayClass is not None and zeroDayFileName: 
        print("using 0 day class", zeroDayClass)
        writeMe0Day = gzip.open(zeroDayFileName, 'w+b')
    if opcodesonly: print ("using only opcodes")
    writeMe = gzip.open(fullAssemblyFileName, 'w+b')

    shortFilesCount = 0
    fileCount = 0
    classCounts = [0]*12

    
    # train_count = 7500
    # total_count = 9100
    
    '''
    dlls cnt
    max ffile len 8406217
    3907 files
    702 windows files
    
    do 9100 total malware + windows + dlls
    
    
    for 45k cutoff: runs out of files around 6249
    to be safe:
    
    5000 train
    1200 test
    
    '''

    # for x in range(0,10500, 500):
    # while fileCount < total_count:
    xMalware = 0
    xBenign1 = 0
    xBenign2 = 0 

    # I only want one copy of all these, keep it here
    zippedFileMalware = malwareRawPrefix + str(xMalware) + ".pklz"
    readMeMalware = gzip.open(zippedFileMalware, "r")

    zippedFileBenign1 = winexeRawPrefix + str(xBenign1) + ".pklz"
    readMeBenign1 = gzip.open(zippedFileBenign1, "r")
    
    zippedFileBenign2 = windllRawPrefix + str(xBenign2) + ".pklz"
    readMeBenign2 = gzip.open(zippedFileBenign2, "r")
    
    
    doneWithExes = False
    
    zeroDayCnt = 0
    while True:
        try:
            readMeNum = random.choice([0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11])
            
            # grabs dlls and malware 2x the rate of exes!!!
            readMe = [readMeMalware, 
                      readMeMalware, 
                      readMeMalware, 
                      readMeMalware, 
                      readMeMalware, 
                      readMeMalware, 
                      readMeBenign1, 
                      readMeBenign2, 
                      readMeBenign2, 
                      readMeBenign2, 
                      readMeBenign2, 
                      readMeBenign2
            ][readMeNum]
            
            
            if fileCount == numSamplesTrain:
                writeMe = gzip.open(validFileName, 'w+b')  # this should clear
            if fileCount == totalSamples: 
                break
                
            fileLines = pickle.load(readMe)
            
            
            while cutoff and len(fileLines[0]) > cutoff:
                # print("class", readMeNum, "over cutoff, trying again")
                fileLines = pickle.load(readMe)
            
            # if opcodesonly:
                # fileLines = getOpcodes(fileLines)
            
            while readMeNum < 6 and zeroDayClass and fileLines[1][0] == zeroDayClass:
                print("found 0 day class, writing to 0day file and rereading")
                fileLines[1] = 1
                # writeMe0Day
                if padLines:
                    # MICHAEL - 18 is maxLineLen... idk
                    pickle.dump(padEachLine(fileLines, 18), writeMe0Day)
                else:
                    # rowSize = 10
                    rowSize = 25
                    # pickle.dump(reformatLines(getOpcodes(fileLines), rowSize), writeMe0Day)
                    pickle.dump(reformatLines(fileLines, rowSize), writeMe0Day)
                
                zeroDayCnt += 1
                fileLines = pickle.load(readMe)
                

            if opcodesonly:
                fileLines = getOpcodes(fileLines)
                
            if binaryAnswers:
                if readMeNum < 6:
                    # 0  malware
                    fileLines[1] = 1 # set all malware to class 1!!!!!
                else:
                    # 1 is benign
                    fileLines[1] = 0 # make sure benign is 0 - I think it's 1 in assemblyVectorizor
            else:
                if readMeNum < 6:
                    # malware
                    pass
                    fileLines[1] = fileLines[1][0]
                    # leave fileLines alone
                elif readMeNum == 6:
                    if not doneWithExes:
                        fileLines[1] = 10
                    else: 
                        fileLines[1] = 11
                        print("we hit a exe randomly but no more exes left!")
                else: 
                    # 3, 4
                    
                    fileLines[1] = 11
                    
            
            if padLines:
                # MICHAEL - 18 is maxLineLen... idk
                pickle.dump(padEachLine(fileLines, 18), writeMe)
            else:
                # rowSize = 10
                rowSize = 25
                # I was worried for a second as this said writeMe0day
                # but that's because I copy pasted it
                # we gooooooooooooooooood
                pickle.dump(reformatLines(fileLines, rowSize), writeMe)
            
            classCounts[fileLines[1]] += 1
            fileCount += 1
            print("file:", fileCount, "len", len(fileLines[0]), "type", readMeNum, "answer", fileLines[1], classCounts)
        except EOFError:
            print ("Error reading num", readMeNum, "starting next file")
            if readMeNum < 6:
                xMalware += 500
                zippedFileMalware = malwareRawPrefix + str(xMalware) + ".pklz"
                readMeMalware = gzip.open(zippedFileMalware, "r")
                
            elif readMeNum == 6:
                # exes !!!
                if doneWithExes:
                    xBenign2 += 500
                    zippedFileBenign2 = windllRawPrefix + str(xBenign2) + ".pklz"
                    readMeBenign2 = gzip.open(zippedFileBenign2, "r")
                    readMeBenign1 = readMeBenign2
                else:
                    xBenign1 += 500
                    if xBenign1 == 1000:
                        doneWithExes = True
                    
                    if doneWithExes:
                        # should only ever hit this once
                        # catch up with the dlls here
                        # then from then on, keep them in sync
                        readMeBenign1 = readMeBenign2
                    else:
                        zippedFileBenign1 = winexeRawPrefix + str(xBenign1) + ".pklz"
                        readMeBenign1 = gzip.open(zippedFileBenign1, "r")
                    
            else :
                xBenign2 += 500
                zippedFileBenign2 = windllRawPrefix + str(xBenign2) + ".pklz"
                readMeBenign2 = gzip.open(zippedFileBenign2, "r")
                # 3 and 4
                # dlls!
                if doneWithExes:
                    readMeBenign1 = readMeBenign2
                    
                    
    if zeroDayClass is not None and zeroDayFileName:
        return zeroDayCnt
                
def compileKaggleAndWindows():
    
    # filePrefix = r"D:\Research\7_Windows_Malware_Detection\dataset\windows_dataset\Win10Home_x86_1803_dlls_disassembled" 
    # vectorizedFolder = r"D:\Research\7_Windows_Malware_Detection\dataset\windows_dataset\opcodes_windowsdllvectorized"
    # createRawVectorizedWindows(filePrefix, vectorizedFolder)
    
    # filePrefix = r"D:\Research\7_Windows_Malware_Detection\dataset\windows_dataset\Win10Home_x86_1803_exes_disassembled" 
    # vectorizedFolder = r"D:\Research\7_Windows_Malware_Detection\dataset\windows_dataset\opcodes_windowsvectorized"
    # createRawVectorizedWindows(filePrefix, vectorizedFolder)
    
    # 0/0
    
    numSamplesTrain = 7500
    totalSamples = 9100
    numSamplesValid = totalSamples - numSamplesTrain
    
    fullAssemblyFileName = r".\datasets\opcodes_windows_exe_dll_kaggle_nopad.pklz"
    validFileName = r".\datasets\opcodes_windows_exe_dll_kaggle_validation_nopad.pklz"
    malwareRawPrefix = r".\datasets\vectorized_kaggle\tempAssemblyVectorized"
    winexeRawPrefix = r".\datasets\vectorized_windows\tempAssemblyVectorized"
    dllRawPrefix = r".\datasets\vectorized_windows\tempAssemblyVectorized"
    
    createFinalVectorizedKaggleAndWindows(fullAssemblyFileName, validFileName, numSamplesTrain, totalSamples,  malwareRawPrefix, winexeRawPrefix, dllRawPrefix,
                                          binaryAnswers=True, padLines=False, opcodesonly=True)
    
    fullAssemblyNamePooled =  r".\datasets\opcodes_windows_exe_dll_kaggle_nopad_pooled.pklz"
    validFileNamePooled = r".\datasets\opcodes_windows_exe_dll_kaggle_validation_nopad_pooled.pklz"
    
    train_gen = loadDataGeneratorBatchesAndPoolBinary(fullAssemblyFileName, numSamplesTrain, fullAssemblyNamePooled)
    valid_gen = loadDataGeneratorBatchesAndPoolBinary(validFileName, numSamplesValid, validFileNamePooled)
    
    '''
    # train_gen = loadDataGeneratorBatchesAndSlideWindow(r"D:\Research\2_Malware_Detection\kaggle_dataset\vectorized\trainASM_all_pooled.pklz", numSamplesTrain,
                                                 # r"D:\Research\2_Malware_Detection\kaggle_dataset\vectorized\trainASM_all_pooled.pklz"
                                                 # )
    # valid_gen = loadDataGeneratorBatchesAndSlideWindow(r"D:\Research\2_Malware_Detection\kaggle_dataset\vectorized\validASM_all_pooled.pklz", numSamplesValid,
                                                 # r"D:\Research\2_Malware_Detection\kaggle_dataset\vectorized\validASM_all_pooled.pklz"
                                                 # )
    '''

    runThroughGenerator(train_gen, numSamplesTrain)
    runThroughGenerator(valid_gen, numSamplesValid)
    
def compileKaggleAndWindows50kCutoff():
    print("compiling kaggle and windows with 45k cutoff")
    # numSamplesTrain = 5000
    # totalSamples = 6200
    numSamplesTrain = 4000
    totalSamples = 5000
    numSamplesValid = totalSamples - numSamplesTrain
    
    
    fullAssemblyFileName = r".\datasets\kagglewindows\no50k\windows_exe_dll_kaggle_no50k.pklz"
    validFileName = r".\datasets\kagglewindows\no50k\windows_exe_dll_kaggle_validation_no50k.pklz"
    malwareRawPrefix = r".\datasets\vectorized_kaggle\tempAssemblyVectorized"
    winexeRawPrefix = r".\datasets\vectorized_windows\tempAssemblyVectorized"
    dllRawPrefix = r".\datasets\vectorized_windows\tempAssemblyVectorized"
    
    createFinalVectorizedKaggleAndWindows(fullAssemblyFileName, validFileName, numSamplesTrain, totalSamples,  malwareRawPrefix, winexeRawPrefix, dllRawPrefix,
                                          binaryAnswers=True, cutoff=50000)
    
    fullAssemblyNamePooled =  r".\datasets\kagglewindows\no50k\windows_exe_dll_kaggle_no50k_pooled.pklz"
    validFileNamePooled = r".\datasets\kagglewindows\no50k\windows_exe_dll_kaggle_validation_no50k_pooled.pklz"
    
    train_gen = loadDataGeneratorBatchesAndPoolBinary(fullAssemblyFileName, numSamplesTrain, fullAssemblyNamePooled)
    valid_gen = loadDataGeneratorBatchesAndPoolBinary(validFileName, numSamplesValid, validFileNamePooled)
    
    '''
    # train_gen = loadDataGeneratorBatchesAndSlideWindow(r"D:\Research\2_Malware_Detection\kaggle_dataset\vectorized\trainASM_all_pooled.pklz", numSamplesTrain,
                                                 # r"D:\Research\2_Malware_Detection\kaggle_dataset\vectorized\trainASM_all_pooled.pklz"
                                                 # )
    # valid_gen = loadDataGeneratorBatchesAndSlideWindow(r"D:\Research\2_Malware_Detection\kaggle_dataset\vectorized\validASM_all_pooled.pklz", numSamplesValid,
                                                 # r"D:\Research\2_Malware_Detection\kaggle_dataset\vectorized\validASM_all_pooled.pklz"
                                                 # )
    '''

    runThroughGenerator(train_gen, numSamplesTrain)
    runThroughGenerator(valid_gen, numSamplesValid)
    
def compileKaggleAndWindows0Day():
    
    # filePrefix = r"D:\Research\7_Windows_Malware_Detection\dataset\windows_dataset\Win10Home_x86_1803_dlls_disassembled" 
    # vectorizedFolder = r"D:\Research\7_Windows_Malware_Detection\dataset\windows_dataset\windowsdllvectorized"
    # createRawVectorizedWindows(filePrefix, vectorizedFolder)
    
    # filePrefix = r"D:\Research\7_Windows_Malware_Detection\dataset\windows_dataset\Win10Home_x86_1803_exes_disassembled" 
    # vectorizedFolder = r"D:\Research\7_Windows_Malware_Detection\dataset\windows_dataset\windowsvectorized"
    # createRawVectorizedWindows(filePrefix, vectorizedFolder)
    
    # 0/0
    
    numSamplesTrain = 7500
    totalSamples = 9100
    numSamplesValid = totalSamples - numSamplesTrain
    
    fullAssemblyFileName = r".\datasets\kagglewindows0day\winkaggle_noclass8_nopad.pklz"
    validFileName = r".\datasets\kagglewindows0day\winkaggle_noclass8_validation_nopad.pklz"
    zeroDayClass = 8
    zeroDayFileName = r".\datasets\kagglewindows0day\winkaggle_onlyclass8_nopad.pklz"
    
    malwareRawPrefix = r".\datasets\vectorized_kaggle\tempAssemblyVectorized"
    winexeRawPrefix = r".\datasets\vectorized_windows\tempAssemblyVectorized"
    dllRawPrefix = r".\datasets\vectorized_windows\tempAssemblyVectorized"
    
    
    zeroDayCnt = createFinalVectorizedKaggleAndWindows(fullAssemblyFileName, validFileName, numSamplesTrain, totalSamples,  malwareRawPrefix, winexeRawPrefix, dllRawPrefix,
                                          binaryAnswers=True, padLines=False, zeroDayClass=zeroDayClass, zeroDayFileName=zeroDayFileName)
    
    fullAssemblyNamePooled =  r".\datasets\kagglewindows0day\winkaggle_noclass8_nopad_pooled.pklz"
    validFileNamePooled = r".\datasets\kagglewindows0day\winkaggle_noclass8_validation_nopad_pooled.pklz"
    zeroDayFileNamePooled = r".\datasets\kagglewindows0day\winkaggle_onlyclass8_nopad_pooled.pklz"
    
    train_gen = loadDataGeneratorBatchesAndPoolBinary(fullAssemblyFileName, numSamplesTrain, fullAssemblyNamePooled)
    valid_gen = loadDataGeneratorBatchesAndPoolBinary(validFileName, numSamplesValid, validFileNamePooled)
    zero_gen = loadDataGeneratorBatchesAndPoolBinary(zeroDayFileName, zeroDayCnt, zeroDayFileNamePooled)
    
    '''
    # train_gen = loadDataGeneratorBatchesAndSlideWindow(r"D:\Research\2_Malware_Detection\kaggle_dataset\vectorized\trainASM_all_pooled.pklz", numSamplesTrain,
                                                 # r"D:\Research\2_Malware_Detection\kaggle_dataset\vectorized\trainASM_all_pooled.pklz"
                                                 # )
    # valid_gen = loadDataGeneratorBatchesAndSlideWindow(r"D:\Research\2_Malware_Detection\kaggle_dataset\vectorized\validASM_all_pooled.pklz", numSamplesValid,
                                                 # r"D:\Research\2_Malware_Detection\kaggle_dataset\vectorized\validASM_all_pooled.pklz"
                                                 # )
    '''

    runThroughGenerator(train_gen, numSamplesTrain)
    runThroughGenerator(valid_gen, numSamplesValid)
    runThroughGenerator(zero_gen, zeroDayCnt)
    
    print("zero day cnt", zeroDayCnt)
    
    
    
    
def compileKaggle():
    # folderPrefix = r"D:\Research\KAGGLE_FULL_DATASET" 
    # vectorizedFolder = r"D:\Research\2_Malware_Detection\kaggle_dataset\tempAssemblyVectorized"
    # stats = createRawVectorizedKaggle(folderPrefix, vectorizedFolder)
    
    stats = {
        "numFiles": 2375 + 8000,
        # "maxLineLen": 18
    }
    
    rawVectorizedPrefix = r"\datasets\vectorized_kaggle\tempAssemblyVectorized"
    vectorizedPrefix = r".\datasets\kaggle"
    
    fullAssemblyFileName = vectorizedPrefix + r"\trainASM_all_nopad_250.pklz"
    validFileName = vectorizedPrefix + r"\validASM_all_nopad_250.pklz"
    
    fullAssemblyNamePooled = vectorizedPrefix + r"\trainASM_all_nopad_250_pooled.pklz"
    validFileNamePooled = vectorizedPrefix + r"\validASM_all_nopad_250_pooled.pklz"
    
    
    numSamplesTrain = 8000
    numSamplesValid = stats["numFiles"] - numSamplesTrain
    
    # use following to pad lines!
    # createFinalVectorizedKaggleOnly(fullAssemblyFileName, validFileName, rawVectorizedPrefix, stats, numSamplesTrain)
    createFinalVectorizedKaggleOnly(fullAssemblyFileName, validFileName, rawVectorizedPrefix, stats, numSamplesTrain, padLines=False)
    
    train_gen = loadDataGeneratorBatchesAndPool(fullAssemblyFileName, numSamplesTrain, fullAssemblyNamePooled)
    valid_gen = loadDataGeneratorBatchesAndPool(validFileName, numSamplesValid, validFileNamePooled)
    
    runThroughGenerator(train_gen, numSamplesTrain)
    runThroughGenerator(valid_gen, numSamplesValid)
    
    # for overlapSize in [15, 20]:
        # print("DOING overlapSize", overlapSize)
        # fullAssemblyNamePooledWindows = vectorizedPrefix + r"\trainASM_all_nopad_pooled_window" + str(overlapSize) + r".pklz"
        # validFileNamePooledWindows = vectorizedPrefix + r"\validASM_all_nopad_pooled_window" + str(overlapSize) + r".pklz"
        
        # train_gen = loadDataGeneratorBatchesAndSlideWindow(fullAssemblyNamePooled, numSamplesTrain,fullAssemblyNamePooledWindows,overlapSize)
        # valid_gen = loadDataGeneratorBatchesAndSlideWindow(validFileNamePooled, numSamplesValid,validFileNamePooledWindows,overlapSize)
        
        # runThroughGenerator(train_gen, numSamplesTrain)
        # runThroughGenerator(valid_gen, numSamplesValid)
        
    pass
    
def compileKaggle50kCutoff():
    
    # 8556 files under 45k
    # 6500 train, 2556 valid
    stats = {
        "numFiles": 2050 + 6500,
        "maxLineLen": 18
    }
    
    rawVectorizedPrefix = r".\datasets\vectorized_kaggle\tempAssemblyVectorized"
    vectorizedPrefix = r".\datasets\kaggle"
    
    fullAssemblyFileName = vectorizedPrefix + r"\trainASM_no50k.pklz"
    validFileName = vectorizedPrefix + r"\validASM_no50k.pklz"
    
    fullAssemblyNamePooled = vectorizedPrefix + r"\trainASM_no50k_pooled.pklz"
    validFileNamePooled = vectorizedPrefix + r"\validASM_no50k_pooled.pklz"
    
    
    numSamplesTrain = 6500
    numSamplesValid = stats["numFiles"] - numSamplesTrain
    
    createFinalVectorizedKaggleOnly(fullAssemblyFileName, validFileName, rawVectorizedPrefix, stats, numSamplesTrain, cutoff=50000)
    
    train_gen = loadDataGeneratorBatchesAndPool(fullAssemblyFileName, numSamplesTrain, fullAssemblyNamePooled)
    valid_gen = loadDataGeneratorBatchesAndPool(validFileName, numSamplesValid, validFileNamePooled)
    
    runThroughGenerator(train_gen, numSamplesTrain)
    runThroughGenerator(valid_gen, numSamplesValid)
    
    
    
if __name__ == "__main__":    
    # compileKaggle()
    
    # countFiles()
    
    # compileKaggleAndWindows0Day()
    compileKaggleAndWindows()
    import os
    # os.system(r'python D:\Research\6_MaV\train.py')
    
    