import numpy as np
import matplotlib.pyplot as plt
from scipy.ndimage.filters import gaussian_filter
from sklearn.feature_extraction.text import TfidfVectorizer
from sklearn.metrics.pairwise import cosine_similarity
import glob, os, gzip, pickle

def blobToImage(blob):
    tokens = blob.split(" ")
    # for token in tokens:
        # print(token)
        # print(token[:-2])
    # comes as 237.0, cut off .-0
    tokens = [int(token[:-2]) for token in tokens]
    arr = np.array(tokens)
    
    arr = arr.reshape((int(arr.shape[0]/25), 25))
    
    return arr

class SequentialClusterer(object):
    def __init__(self):
        self.candidates = []
        
        self.clusters = []  # list of lists!
        self.tfidfList = []
        
        self.lowerN = 1
        self.upperN = 1
        # self.upperN = 4
        
    
    def addCandidates(self, imageList):
        for n in range(0, len(imageList)):
            # imageList[n] = np.array(imageList[n]).flatten()
            # imageList[n] = " ".join([str(item) for item in imageList[n]])
            candidate = np.array(imageList[n]).flatten()
            candidate = " ".join([str(item) for item in candidate])
            
            self.candidates.append(candidate)
            
    def makeTFIDF(self, cluster):
        return TfidfVectorizer(ngram_range=(self.lowerN,self.upperN)).fit(cluster)
            
    def cluster(self):
        # first cluster of just one
        self.clusters.append([self.candidates[0]])
        # TFIDF list - one per cluster
        self.tfidfList.append(self.makeTFIDF(self.clusters[0]))
        
        numClusters = 100
        
        # This is sequential clustering...
        
        print("starting")
        print("number of candidates:", len(self.candidates))
        print("num clusters:", numClusters)
        cnt = 0
        for candidate in self.candidates:
            cnt += 1
            if cnt % 50 == 0: print("done", cnt, "clusters", len(self.clusters))
            
            
            distances = []
            bestAvgDistance = 0
            bestLocation = -1
            
            for n in range(len(self.clusters)):
                cluster = self.clusters[n]
                tfidf = self.tfidfList[n]
                
                clusterTransform = tfidf.transform(cluster)
                candidateTransform = tfidf.transform([candidate])
                
                distances = clusterTransform * candidateTransform.T
                
                # if np.mean(distances) > bestAvgDistance and np.mean(distances) > .3:
                if np.mean(distances) > bestAvgDistance:
                    bestAvgDistance = np.mean(distances)
                    bestLocation = n
            
            # found a cluster for it
            # if bestLocation > -1:
            if bestAvgDistance > .3 or len(self.clusters)  == numClusters:
                cluster = self.clusters[bestLocation]
                cluster.append(candidate)
                
                self.tfidfList[bestLocation] = self.makeTFIDF(cluster)
                
                
                if bestAvgDistance < .3:
                    print("putting in cluster best avg distance:", bestAvgDistance)
            else:
                # if np.sum(np.abs(blobToImage(candidate))) != 0:
                    # self.clusters.append([candidate])
                    # self.tfidfList.append(self.makeTFIDF(self.clusters[-1]))
                # else:
                    # print("FOUND 0 SUM CANDIDATE. SKIPPING.")
                try:
                    self.clusters.append([candidate])
                    self.tfidfList.append(self.makeTFIDF(self.clusters[-1]))
                except:
                    print("FOUND ERR CANDIDATE. SKIPPING.")
                    print(candidate)
                    self.clusters.pop(-1)
        
        f = gzip.open('clusters_hierarchical_BENIGN.pklz', 'w+b')  # this should clear
        pickle.dump(self.clusters, f) # just dump the one file we've scanned
        
        print("turned", len(self.candidates), "candidates into ", len(self.clusters), "clusters")
        longestCluster = []
        longestClusterLoc = 0
        for n, cluster in enumerate(self.clusters):
            print(len(cluster))
            if len(cluster) > len(longestCluster):
                longestCluster = cluster
                longestClusterLoc = n
        
        
        # print("longest cluster items being displayed")
        # for item in longestCluster:
            # fig = plt.figure()
            # ax1 = fig.add_subplot(1,1,1)
            # ax1.imshow(item, cmap='gray')
            # plt.axis('off')
            
            # plt.show()
            
            # print(item)
            
        
        
        
        
        
        